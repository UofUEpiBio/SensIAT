# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Runs a *basic* implementation of the "NW" function with the "K2_Biweight" kernel, just as a
#' proof-of-concept.
#'
#' @param Xb vector (expected to be about 500 elements)
#' @param Y vector (same size as Xb)
#' @param xb vector
#' @param y_seq vector
#' @param h scalar bandwidth of kernel
#' @return Matrix fyxb
pcoriaccel_NW_basic <- function(Xb, Y, xb, y_seq, h) {
    .Call(`_pcoriRPackage_pcoriaccel_NW_basic`, Xb, Y, xb, y_seq, h)
}

#' Runs an optimized implementation of the "NW" function.
#'
#' @param Xb vector (expected to be about 500 elements)
#' @param Y vector (same size as Xb)
#' @param xb vector
#' @param y_seq vector
#' @param h scalar bandwidth of kernel
#' @return Matrix fyxb
pcoriaccel_NW <- function(Xb, Y, xb, y_seq, h, kernel = "K2_Biweight") {
    .Call(`_pcoriRPackage_pcoriaccel_NW`, Xb, Y, xb, y_seq, h, kernel)
}

#' Returns a string, just as a basic check that the C++ plugin library is working.
#' @return hello string
pcoriaccel_hello <- function() {
    .Call(`_pcoriRPackage_pcoriaccel_hello`)
}

#' Multiplies two matrices.  If the first argument is a vector, it is interpreted as a row vector.
#' Otherwise, if the second argument is a vector, it is interpreted as a column vector.
#' @param matrA
#' @param matrB
#' @return matrA * matrB
pcoriaccel_mmul <- function(matrA, matrB) {
    .Call(`_pcoriRPackage_pcoriaccel_mmul`, matrA, matrB)
}

#' Inner product (dot product) of two vectors.
#' @param vecA
#' @param vecB
#' @return vecAᵀ * vecB = vecA • vecB
pcoriaccel_inner <- function(vecA, vecB) {
    .Call(`_pcoriRPackage_pcoriaccel_inner`, vecA, vecB)
}

#' Outer product of two vectors.
#' @param vecA
#' @param vecB
#' @return vecA * vecBᵀ = vecA ⊗ vecB
#' @examples
#' pcoriaccel_outer( c(1,2,3,4,5), c(2,4,6) )
pcoriaccel_outer <- function(vecA, vecB) {
    .Call(`_pcoriRPackage_pcoriaccel_outer`, vecA, vecB)
}

#' Returns the unique elements of a vector, sorted in ascending order.
#' @param vec
#' @return sort(unique(vec))
pcoriaccel_sorted_unique <- function(vec) {
    .Call(`_pcoriRPackage_pcoriaccel_sorted_unique`, vec)
}

#' Runs an optimized implementation of the `compute_influence_term_2_quadv_sim_via_matrix`
#' function.
#'
#' @param X              Matrix of all covariates, transformed as necessary by model
#' @param Y              Vector of all outcomes (same length as a column of `X`)
#' @param times          Vector of observation times for individual
#' @param individual_X   Matrix of covariates for individual rows correspond to times prepared for
NULL

#' @param x_slope        Vector indicating how
#' @param alpha          Vector of sensitivity parameters
#' @param beta           Coefficients of the outcome model
#' @param spline_basis   Spline basis object (`orthogonalsplinebasis::SplineBasis`)
#' @param bandwidth      Bandwidth for the kernel density estimate of the outcome model.
#' @param tol            Tolerance for integration
#' @param ...            Additional arguments passed to the pcoriaccel_NW function, not implemented.
#'
#' @return integration result
#'
pcoriaccel_compute_influence_term_2_quadv_sim_via_matrix <- function(X, Y, times, individual_X, x_slope, alpha, beta, spline_basis, bandwidth, tol = 0.0001220703) {
    .Call(`_pcoriRPackage_pcoriaccel_compute_influence_term_2_quadv_sim_via_matrix`, X, Y, times, individual_X, x_slope, alpha, beta, spline_basis, bandwidth, tol)
}

#' Estimate the PMF directly with the K2_Biweight kernel.
#'
#' @param Xb vector (expected to be about 500 elements)
#' @param Y vector (same size as Xb)
#' @param xi vector
#' @param y_seq vector
#' @param h scalar bandwidth of kernel
#'
#' @return estimated PMF
#'
pcoriaccel_estimate_pmf <- function(X, Y, xi, y_seq, h) {
    .Call(`_pcoriRPackage_pcoriaccel_estimate_pmf`, X, Y, xi, y_seq, h)
}

#' Rcpp version of `evaluate_basis(⋯)` function
#'
#' @param spline_basis   Spline basis, S4 class `orthogonalsplinebasis::SplineBasis`
#' @param x              Evaluation point
#'
#' @return Vector fyxb
#'
pcoriaccel_evaluate_basis <- function(spline_basis, x) {
    .Call(`_pcoriRPackage_pcoriaccel_evaluate_basis`, spline_basis, x)
}

